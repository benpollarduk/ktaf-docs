{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Ktaf is a library that provides a framework for building text adventures and interactive stories in Kotlin or Java.</p> <p>The repo is open source and is available at https://github.com/benpollarduk/ktaf. Ktaf has a sister .Net implementation, NetAF, which is available at https://github.com/benpollarduk/netaf.</p> <p>This documentation site is a work in progress, if there are any topics that aren't covered that you would like to see included, or if you spot any mistakes please report them on the Issues page on GitHub.</p>"},{"location":"api-documentation/","title":"Api Documentation","text":"<p>Please visit https://benpollarduk.github.io/ktaf-api-docs/ to view the Api documentation for Ktaf.</p>"},{"location":"attributes/","title":"Attributes","text":""},{"location":"attributes/#overview","title":"Overview","text":"<p>All examinable objects can have attributes. Attributes provide a way of adding a lot of depth to games. For example,  attributes could be used to buy and sell items, contain a characters XP or HP or even provide a way to add durability  to items.</p>"},{"location":"attributes/#use","title":"Use","text":"<p>To add to an existing attribute or to create a new one use the add function.</p> <pre><code>var player = PlayableCharacter(\"Player\", \"\")\nplayer.attributes.add(\"$\", 10)\n</code></pre> <p>To subtract from an existing attribute use the subtract function.</p> <pre><code>player.attributes.subtract(\"$\", 10)\n</code></pre> <p>Attributes values can be capped. In this example the $ attribute is limited to a range of 0 - 100. Adding or  subtracting will not cause the value of the attribute to change outside of this range.</p> <pre><code>var cappedAttribute = Attribute(\"$\", \"Dollars.\", 0, 100)\nplayer.attributes.add(cappedAttribute, 50)\n</code></pre>"},{"location":"attributes/#an-example-buying-an-item-from-a-nonplayablecharacter","title":"An example - buying an Item from a NonPlayableCharacter.","text":"<p>The following is an example of buying an Item from NonPlayableCharacter. Here a trader has a spade. The player can only buy the spade if they have at least $5. The conversation will jump to the correct paragraph based on if they choose to  buy the spade or not. If the player chooses to buy the spade and has enough $ the transaction is made and the spade  changes hands.</p> <pre><code>val currency = \"$\"\nval spade = Item(\"Spade\", \"\")\n\nval player = PlayableCharacter(\"Player\", \"\").apply {\n    attributes.add(currency, 10)\n}\n\nval trader = NonPlayableCharacter(\"Trader\", \"\").apply {\n    acquireItem(spade)\n    conversation = Conversation(\n        listOf(\n            Paragraph(\"What will you buy\").also {\n                it.responses = listOf(\n                    Response(\"Spade.\", ByCallback {\n                        if (player.attributes.getValue(currency) &gt;= 5) {\n                            ToName(\"BoughtSpade\")\n                        } else {\n                            ToName(\"NotEnough\")\n                        }\n                    }),\n                    Response(\"Nothing.\", Last()),\n                )\n            },\n            Paragraph(\"Here it is.\", First(), \"BoughtSpade\") {\n                player.attributes.subtract(currency, 5)\n                attributes.add(currency, 5)\n                give(spade, player)\n            },\n            Paragraph(\"You don't have enough money.\", First(), \"NotEnough\"),\n            Paragraph(\"Fine.\")\n        ),\n    )\n}\n</code></pre> <p>This is just one example of using attributes to add depth to a game.</p>"},{"location":"commands/","title":"Global Commands","text":""},{"location":"commands/#overview","title":"Overview","text":"<p>There are three main types of Command. * Game Commands are used to interact with the game. * Global Commands are used to interact with the program running the game. * Custom Commands allow developers to add custom commands to the game without having to worry about extended the games interpreters.</p>"},{"location":"commands/#game-commands","title":"Game Commands","text":""},{"location":"commands/#drop","title":"Drop","text":"<p>Allows players to drop an item. R can be used as a shortcut.</p> <pre><code>drop sword\n</code></pre> <p>The player can also drop all items.</p> <pre><code>drop all\n</code></pre>"},{"location":"commands/#examine","title":"Examine","text":"<p>Allows players to examine any asset. X can be used as a shortcut.</p> <p>Examine will examine the current room.</p> <pre><code>examine\n</code></pre> <p>The player themselves can be examined with me or the players name.</p> <pre><code>examine me\n</code></pre> <p>or</p> <pre><code>examine ben\n</code></pre> <p>The same is true for Regions, Overworlds, Items and Exits.</p>"},{"location":"commands/#take","title":"Take","text":"<p>Allows the player to take an Item. T can be used as a shortcut.</p> <pre><code>take sword\n</code></pre> <p>Take all allows the player to take all takeables Items in the current Room.</p> <pre><code>take all\n</code></pre>"},{"location":"commands/#talk","title":"Talk","text":"<p>Talk allows the player to start a conversation with a NonPlayableCharacter. L can be used as a shortcut.</p> <p>If only a single NonPlayableCharacter is in the current Room no argument needs to be specified.</p> <pre><code>talk\n</code></pre> <p>However, if the current Room contains two or more NonPlayableCharacters then to and the NonPlayableCharacters name  must be specified.</p> <pre><code>talk to dave\n</code></pre>"},{"location":"commands/#use","title":"Use","text":"<p>Use allows the player to use the Items that the player has or that are in the current Room.</p> <pre><code>use sword\n</code></pre> <p>Items can be used on the Player, the Room, an Exit, a NonPlayableCharacter or another Item. The target must be specified with the on keyword.</p> <pre><code>use sword on me\n</code></pre> <p>Or</p> <pre><code>use sword on bush\n</code></pre>"},{"location":"commands/#move","title":"Move","text":"<p>Regions are traversed with direction commands.</p> <ul> <li>North or N moves north.</li> <li>East or E moves east.</li> <li>South or S moves south.</li> <li>West or W moves west.</li> <li>Down or D moves down.</li> <li>Up or U moves up.</li> </ul>"},{"location":"commands/#end","title":"End","text":"<p>Only valid during a conversation with a NonPlayableCharacter, the End command will end the conversation.</p> <pre><code>end\n</code></pre>"},{"location":"commands/#global-commands_1","title":"Global Commands","text":""},{"location":"commands/#about","title":"About","text":"<p>Displays a screen containing information about the game.</p> <pre><code>about\n</code></pre>"},{"location":"commands/#commandson-commandsoff","title":"CommandsOn / CommandsOff","text":"<p>Toggles the display of the contextual commands on the screen on and off.</p> <pre><code>commandson\n</code></pre> <p>Or</p> <pre><code>commandsoff\n</code></pre>"},{"location":"commands/#exit","title":"Exit","text":"<p>Exit the current game.</p> <pre><code>exit\n</code></pre>"},{"location":"commands/#help","title":"Help","text":"<p>Displays a Help screen listing all available commands.</p> <pre><code>help\n</code></pre>"},{"location":"commands/#keyon-keyoff","title":"KeyOn / KeyOff","text":"<p>Toggles the display of the map key on and off.</p> <pre><code>keyon\n</code></pre> <p>Or</p> <pre><code>keyoff\n</code></pre>"},{"location":"commands/#map","title":"Map","text":"<p>Displays the Region map screen.</p> <pre><code>map\n</code></pre>"},{"location":"commands/#new","title":"New","text":"<p>Starts a new game.</p> <pre><code>new\n</code></pre>"},{"location":"commands/#custom-commands","title":"Custom Commands","text":"<p>Custom commands can be added to many of the assets, including Room, PlayableCharacter, NonPlayableCharacter, Item and  Exit.</p>"},{"location":"conditional-descriptions/","title":"Conditional Descriptions","text":""},{"location":"conditional-descriptions/#overview","title":"Overview","text":"<p>Normally assets are assigned a Description during the constructor. This is what is returned when the asset is  examined.</p> <p>Descriptions are usually specified as a string.</p> <pre><code>val item = Item(\"The items name\", \"The items description.\")\n</code></pre> <p>They can also be specified as a Description.</p> <pre><code>val item = Item(Identifier(\"The items name\"), Description(\"The items description.\"))\n</code></pre> <p>However, sometimes it may be desirable to have a conditional description that can change based on the state of the  asset.</p> <p>Conditional descriptions can be specified with ConditionalDescription and contain a lambda which determines which  one of two strings are returned when the asset is examined.</p> <pre><code> // the player, just for demo purposes\nval player = PlayableCharacter(\"Ben\", \"A man.\")\n\n// the description to use when the condition is true\nval trueString = \"A gleaming sword, owned by Ben.\"\n\n// the string to use when the condition is false\nval falseString = \"A gleaming sword, without an owner.\"\n\n// the conditional description itself\nval conditionalDescription = ConditionalDescription(trueString, falseString) {\n    player.findItem(\"Sword\") != null\n}\n\n// create the item with the conditional description\nval sword = Item(Identifier(\"Sword\"), conditionalDescription)\n</code></pre>"},{"location":"end-conditions/","title":"End Conditions","text":""},{"location":"end-conditions/#overview","title":"Overview","text":"<p>The EndCheck class allows the game to determine if it has come to an end. Each game has two end conditions * GameOverCondition when the game is over, but has not been won. * CompletionCondition when the game is over because it has been won.</p>"},{"location":"end-conditions/#use","title":"Use","text":"<p>When an EndCheck is invoked it returns an EndCheckResult. The EndCheckResult details the result of the check to see if the game has ended.</p> <pre><code>fun isGameOver(Game game): EndCheckResult\n{\n    if (game.player.isAlive)\n        return EndCheckResult.NotEnded\n\n    return EndCheckResult(true, \"Game Over\", \"You died!\")\n}\n</code></pre> <p>The GameOverCondition and CompletionCondition are passed in to the game as arguments when a game is created.</p>"},{"location":"exit/","title":"Exit","text":""},{"location":"exit/#overview","title":"Overview","text":"<p>An Exit is essentially a connector between to adjoining rooms.</p>"},{"location":"exit/#use","title":"Use","text":"<p>An Exit can be simply instantiated with a direction.</p> <pre><code>val exit = Exit(Direction.North)\n</code></pre> <p>An Exit can be hidden from the player by setting its isPlayerVisible property to false. This can be set in the  constructor.</p> <pre><code>val exit = Exit(Direction.NORTH, false)\n</code></pre> <p>Or set explicitly.</p> <pre><code>exit.isPlayerVisible = false\n</code></pre> <p>Optionally, a description of the Exit can be specified.</p> <pre><code>val exit = Exit(Direction.NORTH, true, Description(\"A door covered in ivy.\"))\n</code></pre> <p>This will be returned if the player examines the Exit.</p> <p>Like all Examinable objects, an Exit can be assigned custom commands.</p> <pre><code>exit.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Shove\", \"Shove the door.\"),\n        true\n    ) { game, args -&gt;\n        exit.unlock()\n        Reaction(ReactionResult.OK, \"The door swung open.\");\n    }\n)\n</code></pre>"},{"location":"frame-builders/","title":"Overview","text":"<p>In Ktaf output is handled using the FrameBuilders. A FrameBuilder is essentially a class that builds a Frame that can render a specific state in the game. This Frame can then be rendered on a TextWriter by calling its Render method. Think of the FrameBuilder as the instructions that build the output display and the Frame as the output itself.</p> <p>There are a few types of FrameBuilder, each responsible for rendering a specific game state.</p> <p>SceneFrameBuilder is responsible for building frames that render the scenes in a game.</p> <p>ConversationFrameBuilder is responsible for building a frame that can render a conversation.</p> <p>RegionMapFrameBuilder is responsible for building a frame that displays a map of a Region.</p> <p>TransitionFrameBuilder is responsible for building frames that display transitions.</p> <p>AboutFrameBuilder is responsible for building a frame to display the about information.</p> <p>HelpFrameBuilder is responsible for building frames to display the help.</p> <p>GameOverFrameBuilder is responsible for building a frame to display the game over screen.</p> <p>CompletionFrameBuilder is responsible for building a frame to display the completion screen.</p> <p>TitleFrameBuilder is responsible for building the title screen frame.</p> <p>A game accepts a FrameBuilderCollection. A FrameBuilderCollection is a collection of all the different FrameBuilders required to render a game. All FrameBuilders are extensible, so the output for all parts of the  game can be fully customised.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#adding-the-package-to-your-project","title":"Adding the package to your project","text":"<p>You need to pull Ktaf into your project. The easiest way to do this is to add the package. The latest package and  installation instructions are available here.</p>"},{"location":"getting-started/#first-game","title":"First Game","text":"<p>Once the package has been installed it's time to jump in and start building your first game.</p>"},{"location":"getting-started/#setup","title":"Setup","text":"<p>To start with create a new Console application. It should look something like this:</p> <pre><code>package com.github.benpollarduk.ktaf.gettingstarted\n\nobject Main {\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n\n    }\n}\n</code></pre>"},{"location":"getting-started/#adding-a-playablecharacter","title":"Adding a PlayableCharacter","text":"<p>Every game requires a character to play as, lets add that next:</p> <pre><code>private fun createPlayer(): PlayableCharacter {\n    return PlayableCharacter(\"Dave\", \"A young boy on a quest to find the meaning of life.\")\n}\n</code></pre> <p>In this example whenever createPlayer is called a new PlayableCharacter will be created. The character is  called \"Dave\" and has a description that describes him as \"A young boy on a quest to find the meaning of life.\".</p>"},{"location":"getting-started/#creating-the-game-world","title":"Creating the game world","text":"<p>The game world consists of a hierarchy of three tiers: Overworld, Region and Room. We will create a simple  Region with two Rooms. We can do this directly in the main function for simplicity. To start with lets make  the Rooms:</p> <pre><code>@JvmStatic\nfun main(args: Array&lt;String&gt;) {\n    val cavern = Room(\n        \"Cavern\",\n        \"A dark cavern set in to the base of the mountain.\",\n        listOf(\n            Exit(Direction.NORTH),\n        ),\n    )\n\n    val tunnel = Room(\n        \"Tunnel\",\n        \"A dark tunnel leading inside the mountain.\",\n        listOf(\n            Exit(Direction.SOUTH),\n        ),\n    )\n}\n</code></pre> <p>Although the Rooms haven't been added to a Region yet there are exits in place that will allow the player to  move between them.</p> <p>Games are boring without Items to interact with, let's add an item to the tunnel:</p> <pre><code>val holyGrail = Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true)\n\ntunnel.addItem(holyGrail)\n</code></pre> <p>Looking good, but the Rooms need to be contained within a Region. RegionMaker simplifies this process,  but sometimes creating a Region directly may be more appropriate if more control is needed. Here we will  use RegionMaker:</p> <pre><code>val regionMaker = RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\").also {\n    it[0, 0, 0] = cavern\n    it[0, 1, 0] = tunnel\n}\n</code></pre> <p>This needs more breaking down. The RegionMaker will create a region called \"Mountain\" with a description of \"An  imposing volcano just East of town.\". The region will contain two rooms, the cavern and the tunnel. The cavern will be  added at position x 0, y 0, z 0. The tunnel will be added at position x 0, y 1, z 0, north of the cavern.</p> <p>The game world is nearly complete, but the Region needs to exist within an Overworld for it to be finished. We  will use OverworldMaker to achieve this:</p> <pre><code>val overworldMaker = OverworldMaker(\n    \"Daves World\",\n    \"An ancient kingdom.\", listOf(\n        regionMaker\n    )\n)\n</code></pre> <p>This will create an Overworld called \"Daves World\" which is described as \"An ancient kingdom\" and contains a  single Region.</p> <p>All together the code looks like this:</p> <pre><code>val cavern = Room(\n    \"Cavern\",\n    \"A dark cavern set in to the base of the mountain.\",\n    listOf(\n        Exit(Direction.NORTH),\n    ),\n)\n\nval tunnel = Room(\n    \"Tunnel\",\n    \"A dark tunnel leading inside the mountain.\",\n    listOf(\n        Exit(Direction.SOUTH),\n    ),\n)\n\nval holyGrail = Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true)\n\ntunnel.addItem(holyGrail)\n\nval regionMaker = RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\").also {\n    it[0, 0, 0] = cavern\n    it[0, 1, 0] = tunnel\n}\n\nval overworldMaker = OverworldMaker(\n    \"Daves World\",\n    \"An ancient kingdom.\", listOf(\n        regionMaker\n    )\n)\n</code></pre>"},{"location":"getting-started/#checking-the-game-is-complete","title":"Checking the game is complete","text":"<p>For a game to come to an end it needs to either hit a game over state or a completion state.</p> <p>Firstly lets look at the logic that determines if the game is complete. An EndCheck is required, which returns an  EndCheckResult that determines if the game is complete.</p> <p>In this example lets make a function that determines if the game is complete. The game is complete if the player has  the holy grail:</p> <pre><code>private fun isGameComplete(game: Game): EndCheckResult {\n    if (game.player.findItem(\"Holy Grail\") == null) {\n        return EndCheckResult.notEnded\n    }\n\n    return EndCheckResult(true, \"Game Complete\", \"You have the Holy Grail!\")\n}\n</code></pre> <p>If the player has the holy grail then the EndCheckResult will return that the game has ended, and have a title that  will read \"Game Complete\" and a description that reads \"You have the Holy Grail!\".</p> <p>A common game over state may be if the player dies:</p> <pre><code>private fun isGameOver(game: Game): EndCheckResult {\n    if (game.player.isAlive) {\n        return EndCheckResult.notEnded\n    }\n\n    return EndCheckResult(true, \"Game Over\", \"You died!\")\n}\n</code></pre>"},{"location":"getting-started/#creating-the-game","title":"Creating the game","text":"<p>The game now has all the required assets and logic it just needs some boilerplate to tie everything together before it  is ready to play.</p> <p>A GameCreationCallback is required to instantiate an instance of a Game. This is so that new instances of the  Game can be created as required.</p> <pre><code>val gameTemplate = object : GameTemplate() {\n    override fun instantiate(ioConfiguration: IOConfiguration): Game {\n        return Game(\n            GameInformation(\n                \"The Life Of Dave\",\n                \"Dave awakes to find himself in a cavern...\",\n                \"A very low budget adventure.\",\n                \"Ben Pollard\"\n            ),\n            createPlayer(),\n            overworldMaker.make(),\n            { isGameComplete(it) },\n            { isGameOver(it) },\n            ioConfiguration = ioConfiguration\n        )\n    }\n}\n</code></pre> <p>This requires some breaking down. A new subclass of GameTemplate is created. A GameTemplate is required to  execute a game because the GameExecutor, the class responsible for executing games may need to instantiate more than  one instance of the game. When instantiate is called a new instance of Game is returned. The constructor for Game class takes the following arguments: GameInformation - information abut the game. Player - the player. Overworld - the overworld. CompletionCondition - a callback for determining if the game is complete. Here it is passed a lambda, which in turn passes in the player to the function. GameOverCondition - a callback for determining if the game is over. Here it is passed a lambda, which in turn passes in the player to the function. IOConfiguration - a configuration that allows Ktaf to be used with different applications. Here the ioConfiguration which is passed in when the instantiate function is called is used.</p>"},{"location":"getting-started/#executing-the-game","title":"Executing the game","text":"<p>As previously mentioned, the GameExecutor is responsible for executing the game. GameExecutor can execute games  either synchronously or asynchronously. For console applications synchronous execution is appropriate. However, for  other types of application asynchronous execution may be required. As this is a console application synchronous execution  is most appropriate. The ExitMode has been set to RETURN_TO_TITLE_SCREEN so that when the game ends, either on  completion, game over or when the player chooses to exit the game by tying the Exit command, the application will  return to the title screen. The AnsiConsoleConfiguration is used, this configures the game to be run on an ANSI  compatible console. Other configurations can be created to allow Ktaf to function with other types of application, see  the examples in the repo for more information.</p> <pre><code>GameExecutor.execute(\n    gameTemplate,\n    ExitMode.RETURN_TO_TITLE_SCREEN,\n    AnsiConsoleConfiguration\n)\n</code></pre>"},{"location":"getting-started/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The full example code should look like this:</p> <pre><code>package com.github.benpollarduk.ktaf.gettingstarted\n\nimport com.github.benpollarduk.ktaf.assets.Item\nimport com.github.benpollarduk.ktaf.assets.characters.PlayableCharacter\nimport com.github.benpollarduk.ktaf.assets.locations.Direction\nimport com.github.benpollarduk.ktaf.assets.locations.Exit\nimport com.github.benpollarduk.ktaf.assets.locations.Room\nimport com.github.benpollarduk.ktaf.io.IOConfiguration\nimport com.github.benpollarduk.ktaf.io.configurations.AnsiConsoleConfiguration\nimport com.github.benpollarduk.ktaf.logic.ExitMode\nimport com.github.benpollarduk.ktaf.logic.Game\nimport com.github.benpollarduk.ktaf.logic.GameExecutor\nimport com.github.benpollarduk.ktaf.logic.GameInformation\nimport com.github.benpollarduk.ktaf.logic.conditions.EndCheckResult\nimport com.github.benpollarduk.ktaf.utilities.OverworldMaker\nimport com.github.benpollarduk.ktaf.utilities.RegionMaker\nimport com.github.benpollarduk.ktaf.utilities.templates.GameTemplate\n\nobject Main {\n    private fun createPlayer(): PlayableCharacter {\n        return PlayableCharacter(\"Dave\", \"A young boy on a quest to find the meaning of life.\")\n    }\n\n    private fun isGameComplete(game: Game): EndCheckResult {\n        if (game.player.findItem(\"Holy Grail\") == null) {\n            return EndCheckResult.notEnded\n        }\n\n        return EndCheckResult(true, \"Game Complete\", \"You have the Holy Grail!\")\n    }\n\n    private fun isGameOver(game: Game): EndCheckResult {\n        if (game.player.isAlive) {\n            return EndCheckResult.notEnded\n        }\n\n        return EndCheckResult(true, \"Game Over\", \"You died!\")\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        val cavern = Room(\n            \"Cavern\",\n            \"A dark cavern set in to the base of the mountain.\",\n            listOf(\n                Exit(Direction.NORTH),\n            ),\n        )\n\n        val tunnel = Room(\n            \"Tunnel\",\n            \"A dark tunnel leading inside the mountain.\",\n            listOf(\n                Exit(Direction.SOUTH),\n            ),\n        )\n\n        val holyGrail = Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true)\n\n        tunnel.addItem(holyGrail)\n\n        val regionMaker = RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\").also {\n            it[0, 0, 0] = cavern\n            it[0, 1, 0] = tunnel\n        }\n\n        val overworldMaker = OverworldMaker(\n            \"Daves World\",\n            \"An ancient kingdom.\",\n            listOf(\n                regionMaker,\n            ),\n        )\n\n        val gameTemplate = object : GameTemplate() {\n            override fun instantiate(ioConfiguration: IOConfiguration): Game {\n                return Game(\n                    GameInformation(\n                        \"The Life Of Dave\",\n                        \"Dave awakes to find himself in a cavern...\",\n                        \"A very low budget adventure.\",\n                        \"Ben Pollard\",\n                    ),\n                    createPlayer(),\n                    overworldMaker.make(),\n                    { isGameComplete(it) },\n                    { isGameOver(it) },\n                    ioConfiguration = AnsiConsoleConfiguration,\n                )\n            }\n        }\n\n        GameExecutor.execute(\n            gameTemplate,\n            ExitMode.RETURN_TO_TITLE_SCREEN,\n            AnsiConsoleConfiguration,\n        )\n    }\n}\n</code></pre> <p>Simply build and run the application and congratulations, you have a working Ktaf game!</p>"},{"location":"items/","title":"Item","text":""},{"location":"items/#overview","title":"Overview","text":"<p>Items can be used to add interactivity with a game. Items can be something that a player can take with them, or they may be static in a Room.</p>"},{"location":"items/#use","title":"Use","text":"<p>An Item can be simply instantiated with a name and description.</p> <pre><code>val sword = Item(\"Sword\", \"A heroes sword.\")\n</code></pre> <p>By default, an Item is not takeable and is tied to a Room. If it is takeable this can be specified in the constructor.</p> <pre><code>val sword = Item(\"Sword\", \"A heroes sword.\", true)\n</code></pre> <p>An Item can morph in to another Item. This is useful in situations where the Item changes state. Morphing is invoked  with the morph function. The Item that morph is invoked on takes on the properties of the Item being morphed into.</p> <pre><code>val brokenSword = Item(\"Broken Sword\", \"A broken sword\")\nsword.morph(brokenSword)\n</code></pre> <p>Like all Examinable objects, an Item can be assigned custom commands.</p> <pre><code>bomb.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Cut wire\", \"Cut the red wire.\"),\n        true\n    ) { game, args -&gt;\n        game.player.kill()\n        Reaction(ReactionResult.OK, \"Boom!\")\n    }\n)\n</code></pre>"},{"location":"items/#interaction","title":"Interaction","text":"<p>Interactions can be set up between different assets in the game. The InteractionResult contains the result of the  interaction, and allows the game to react to the interaction.</p> <pre><code>val dartsBoard = Item(\"Darts board\", \"A darts board.\")\n\nval dart = Item(\"Dart\", \"A dart\").apply {\n    interaction = {\n        if (it == dartsBoard) {\n            InteractionResult(\n                InteractionEffect.SELF_CONTAINED,\n                it,\n                \"The dart stuck in the darts board.\",\n            )\n        }\n\n        InteractionResult(InteractionEffect.NO_EFFECT, it)\n    }\n}\n</code></pre>"},{"location":"non-playable-character/","title":"NonPlayableCharacter","text":""},{"location":"non-playable-character/#overview","title":"Overview","text":"<p>A NonPlayableCharacter represents any character that the player may meet throughout the game.</p>"},{"location":"non-playable-character/#use","title":"Use","text":"<p>A NonPlayableCharacter can be simply instantiated with a name and description.</p> <pre><code>var goblin = NonPlayableCharacter(\"Goblin\", \"A vile goblin.\")\n</code></pre> <p>A NonPlayableCharacter can give an item to another NonPlayableCharacter.</p> <pre><code>var daisy = Item(\"Daisy\", \"A beautiful daisy that is sure to cheer up even the most miserable creature.\");\nnpc.give(daisy, goblin);\n</code></pre> <p>NonPlayableCharacters can contain custom commands that allow the user to directly interact with the character or other  assets.</p> <pre><code>goblin.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Smile\", \"Crack a smile.\"),\n        true\n    ) { game, args -&gt;\n        Reaction(ReactionResult.OK, \"Well that felt weird.\");\n    }\n)\n</code></pre>"},{"location":"non-playable-character/#conversations","title":"Conversations","text":"<p>A NonPlayableCharacter can hold a conversation with the player.  * A Conversation contains Paragraphs.  * A Paragraph can contain one or more Responses. * A Response can contain a delta to shift the conversation by, which will cause the conversation to jump paragraphs by the specified value. * A Response can also contain a callback to perform some action when the player selects that option.</p> <pre><code>goblin.conversation = Conversation(\n    listOf(\n        Paragraph(\"This is a the first line.\"),\n        Paragraph(\"This is a question.\").also {\n            it.responses = listOf(\n                Response(\"This is the first response.\", Jump(1)),\n                Response(\"This is the second response.\", Jump(2)),\n                Response(\"This is the third response.\", Jump(3)),\n            )\n        },\n        Paragraph(\"You picked first response, return to start of conversation.\", GoTo(1)),\n        Paragraph(\"You picked second response, return to start of conversation.\", GoTo(1)),\n        Paragraph(\"This is the third response.\") {\n            it.player.kill()\n        },\n    ),\n)\n</code></pre>"},{"location":"overworld/","title":"Overworld","text":""},{"location":"overworld/#overview","title":"Overview","text":"<p>An Overworld is the top level location in a game. A game can only contain a single Overworld. An Overworld can contain  multiple Regions.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre>"},{"location":"overworld/#use","title":"Use","text":"<p>An Overworld can be simply instantiated with a name and description.</p> <pre><code>val overworld = Overworld(\"Name\", \"Description.\")\n</code></pre> <p>Regions can be added to the Overworld with the addRegion function.</p> <pre><code>overworld.addRegion(region)\n</code></pre> <p>Regions can be removed from an Overworld with the removeRegion function.</p> <pre><code>overworld.removeRegion(region)\n</code></pre> <p>The Overworld can be traversed with the move function.</p> <pre><code>overworld.move(region)\n</code></pre>"},{"location":"overworld/#overworldmaker","title":"OverworldMaker","text":"<p>The OverworldMaker simplifies the creation of the Overworld, when used in conjunction with RegionMakers.</p> <pre><code>val overworldMaker = OverworldMaker(\"Name\", \"Description.\", regionMakers)\n</code></pre> <p>However, the main benefit of using an OverworldMaker is that it allows multiple instances of an Overworld to be created  from a single definition of an Overworld.</p> <pre><code>val overworld = overworldMaker.make()\n</code></pre>"},{"location":"playable-character/","title":"PlayableCharacter","text":""},{"location":"playable-character/#overview","title":"Overview","text":"<p>A PlayableCharacter represents the character that the player plays as throughout the game. Each game has only a single  PlayableCharacter.</p>"},{"location":"playable-character/#use","title":"Use","text":"<p>A PlayableCharacter can be simply instantiated with a name and description.</p> <pre><code>val player = PlayableCharacter(\"Ben\", \"A 39 year old man.\")\n</code></pre> <p>A PlayableCharacter can be also be instantiated with a list of Items.</p> <pre><code>val player = PlayableCharacter(\"Ben\", \"A 39 year old man.\", listOf(\n    Item(\"Guitar\", \"A PRS Custom 22, in whale blue, of course.\"),\n    Item(\"Wallet\", \"An empty wallet, of course.\")\n)\n</code></pre> <p>A PlayableCharacter can be given items with the acquireItem function.</p> <pre><code>player.acquireItem(Item(\"Mallet\", \"A large mallet.\"))\n</code></pre> <p>A PlayableCharacter can lose an item with the dequireItem function.</p> <pre><code>player.dequireItem(mallet)\n</code></pre> <p>A PlayableCharacter can use an item on another asset:</p> <pre><code>val trapDoor = Exit(Direction.DOWN)\nval mallet = Item(\"Mallet\", \"A large mallet.\")\nplayer.useItem(mallet, trapDoor)\n</code></pre> <p>A PlayableCharacter can give an item to a non-playable character.</p> <pre><code>val goblin = NonPlayableCharacter(\"Goblin\", \"A vile goblin.\")\nval daisy = Item(\"Daisy\", \"A beautiful daisy that is sure to cheer up even the most miserable creature.\")\nplayer.give(daisy, goblin)\n</code></pre> <p>PlayableCharacters can contain custom commands that allow the user to directly interact with the character or other  assets.</p> <pre><code>player.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Punch wall\", \"Punch the wall.\"),\n        true\n    ) { game, args -&gt;\n        Reaction(ReactionResult.OK, \"You punched the wall.\");\n    }\n)\n</code></pre>"},{"location":"region/","title":"Region","text":""},{"location":"region/#overview","title":"Overview","text":"<p>A Region is the intermediate level location in a game. An Overworld can contain multiple Regions. A Region can contain  multiple Rooms.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre> <p>A Region represents a 3D space. </p> <p>The x location always refers to the horizontal axis, with lower values being west and higher values being east. The y location always refers to the vertical axis, with lower values being south and higher values being north. The z location always refers to the depth axis, with lower values being down and higher values being up.</p>"},{"location":"region/#use","title":"Use","text":"<p>A Region can be simply instantiated with a name and description.</p> <pre><code>val region = Region(\"Name\", \"Description.\")\n</code></pre> <p>Rooms can be added to the Region with the addRoom function. The x, y and z location within the Region must be  specified.</p> <pre><code>region.addRoom(room, 0, 0, 0)\n</code></pre> <p>Rooms can be removed from a Region with the removeRoom function.</p> <pre><code>region.removeRoom(room)\n</code></pre> <p>The Region can be traversed with the move method.</p> <pre><code>region.move(Direction.NORTH)\n</code></pre> <p>The start position, that is the position that the Player will start in when entering a Region, can be specified  with setStartPosition.</p> <pre><code>region.setStartPosition(0, 0, 0)\n</code></pre> <p>The unlockDoorPair function can be used to unlock an Exit in the current Room, which will also unlock the  corresponding Exit in the adjoining Room.</p> <pre><code>region.unlockDoorPair(Direction.EAST)\n</code></pre> <p>Like all Examinable objects, Regions can be assigned custom commands.</p> <pre><code>region.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Warp\", \"Warp to the start.\"),\n        true\n    ) { game, args -&gt;\n        region.jumpToRoom(0, 0, 0)\n        Reaction(ReactionResult.OK, \"You warped to the start.\");\n    }\n)\n</code></pre>"},{"location":"region/#regionmaker","title":"RegionMaker","text":"<p>The RegionMaker simplifies the creation of a Region. Rooms are added to the Region with a specified x, y and  z position within the Region.</p> <pre><code>val regionMaker = RegionMaker(\"Region\", \"Description.\").also {\n    it[0, 0, 0] = Room(\"Room 1\", \"Description of room 1.\")\n    it[1, 0, 0] = Room(\"Room 2\", \"Description of room 2.\")\n}\n</code></pre> <p>The main benefit of using a RegionMaker is that it allows multiple instances of a Region to be created from a single  definition of a Region.</p> <pre><code>val region = regionMaker.make()\n</code></pre>"},{"location":"room/","title":"Room","text":""},{"location":"room/#overview","title":"Overview","text":"<p>A Room is the lowest level location in a game. A Region can contain multiple Rooms.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre> <p>A Room can contain up to six Exits, one for each of the directions north, east, south, west, up and  down.</p>"},{"location":"room/#use","title":"Use","text":"<p>A Region can be simply instantiated with a name and description.</p> <pre><code>val room = Room(\"Name\", \"Description.\")\n</code></pre> <p>Exits can be added to the Room with the addExit function.</p> <pre><code>room.addExit(Exit(Direction.EAST));\n</code></pre> <p>Exits can be removed from a Room with the removeExit function.</p> <pre><code>region.removeExit(exit);\n</code></pre> <p>Items can be added to the Room with the addItem function.</p> <pre><code>room.addItem(Item(\"Name\", \"Description.\"))\n</code></pre> <p>Items can be removed from a Room with the removeItem function.</p> <pre><code>region.removeItem(item)\n</code></pre> <p>Characters can be added to the Room with the addCharacter function.</p> <pre><code>room.addCharacter(NonPlayableCharacter(\"Name\", \"Description.\"))\n</code></pre> <p>Characters can be removed from a Room with the removeCharacter function.</p> <pre><code>region.removeCharacter(character)\n</code></pre> <p>Rooms can contain custom commands that allow the user to directly interact with the Room.</p> <pre><code>room.commands = listOf(\n    CustomCommand(\n        CommandHelp(\"Pull lever\", \"Pull the lever.\"),\n        true\n    ) { game, args -&gt;\n        val exit = room.findExit(Direction.EAST, true)\n        exit.unlock()\n        Reaction(ReactionResult.OK, \"The exit was unlocked.\");\n    }\n)\n</code></pre>"}]}