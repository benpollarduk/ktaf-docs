{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Ktaf is a C# library that provides a framework for building text adventures and interactive stories in Kotlin or Java.</p> <p>The repo is open source and is available at https://github.com/benpollarduk/ktaf. Ktaf has a sister .Net implementation, BP.AdventureFramework, which is available at https://github.com/benpollarduk/bp.adventureframework.</p> <p>This documentation site is a work in progress, if there are any topics that aren't covered that you would like to see included, or if you spot any mistakes please report them on the Issues page on GitHub.</p>"},{"location":"commands/","title":"Global Commands","text":""},{"location":"commands/#overview","title":"Overview","text":"<p>There are three main types of Command. * Game Commands are used to interact with the game. * Global Commands are used to interact with the program running the game. * Custom Commands allow developers to add custom commands to the game without having to worry about extended the games interpreters.</p>"},{"location":"commands/#game-commands","title":"Game Commands","text":""},{"location":"commands/#drop","title":"Drop","text":"<p>Allows players to drop an item. R can be used as a shortcut.</p> <pre><code>drop sword\n</code></pre> <p>The player can also drop all items.</p> <pre><code>drop all\n</code></pre>"},{"location":"commands/#examine","title":"Examine","text":"<p>Allows players to examine any asset. X can be used as a shortcut.</p> <p>Examine will examine the current room.</p> <pre><code>examine\n</code></pre> <p>The player themselves can be examined with me or the players name.</p> <pre><code>examine me\n</code></pre> <p>or</p> <pre><code>examine ben\n</code></pre> <p>The same is true for Regions, Overworlds, Items and Exits.</p>"},{"location":"commands/#take","title":"Take","text":"<p>Allows the player to take an Item. T can be used as a shortcut.</p> <pre><code>take sword\n</code></pre> <p>Take all allows the player to take all takeables Items in the current Room.</p> <pre><code>take all\n</code></pre>"},{"location":"commands/#talk","title":"Talk","text":"<p>Talk allows the player to start a conversation with a NonPlayableCharacter. L can be used as a shortcut.</p> <p>If only a single NonPlayableCharacter is in the current Room no argument needs to be specified.</p> <pre><code>talk\n</code></pre> <p>However, if the current Room contains two or more NonPlayableCharacters then to and the NonPlayableCharacters name must be specified.</p> <pre><code>talk to dave\n</code></pre>"},{"location":"commands/#use","title":"Use","text":"<p>Use allows the player to use the Items that the player has or that are in the current Room.</p> <pre><code>use sword\n</code></pre> <p>Items can be used on the Player, the Room, an Exit, a NonPlayableCharacter or another Item. The target must be specified with the on keyword.</p> <pre><code>use sword on me\n</code></pre> <p>Or</p> <pre><code>use sword on bush\n</code></pre>"},{"location":"commands/#move","title":"Move","text":"<p>Regions are traversed with direction commands.</p> <ul> <li>North or N moves north.</li> <li>East or E moves east.</li> <li>South or S moves south.</li> <li>West or W moves west.</li> <li>Down or D moves down.</li> <li>Up or U moves up.</li> </ul>"},{"location":"commands/#end","title":"End","text":"<p>Only valid during a conversation with a NonPlayableCharacter, the End command will end the conversation.</p> <pre><code>end\n</code></pre>"},{"location":"commands/#global-commands_1","title":"Global Commands","text":""},{"location":"commands/#about","title":"About","text":"<p>Displays a screen containing information about the game.</p> <pre><code>about\n</code></pre>"},{"location":"commands/#commandson-commandsoff","title":"CommandsOn / CommandsOff","text":"<p>Toggles the display of the contextual commands on the screen on and off.</p> <pre><code>commandson\n</code></pre> <p>Or</p> <pre><code>commandsoff\n</code></pre>"},{"location":"commands/#exit","title":"Exit","text":"<p>Exit the current game.</p> <pre><code>exit\n</code></pre>"},{"location":"commands/#help","title":"Help","text":"<p>Displays a Help screen listing all available commands.</p> <pre><code>help\n</code></pre>"},{"location":"commands/#keyon-keyoff","title":"KeyOn / KeyOff","text":"<p>Toggles the display of the map key on and off.</p> <pre><code>keyon\n</code></pre> <p>Or</p> <pre><code>keyoff\n</code></pre>"},{"location":"commands/#map","title":"Map","text":"<p>Displays the Region map screen.</p> <pre><code>map\n</code></pre>"},{"location":"commands/#new","title":"New","text":"<p>Starts a new game.</p> <pre><code>new\n</code></pre>"},{"location":"commands/#custom-commands","title":"Custom Commands","text":"<p>Custom commands can be added to many of the assets, including Room, PlayableCharacter, NonPlayableCharacter, Item and Exit.</p>"},{"location":"conditional-descriptions/","title":"Conditional Descriptions","text":""},{"location":"conditional-descriptions/#overview","title":"Overview","text":"<p>Normally assets are assigned a Description during the constructor. This is what is returned when the asset is examined.</p> <p>Descriptions are usually specified as a string.</p> <pre><code>var item = new Item(\"The items name\", \"The items description.\");\n</code></pre> <p>They can also be specified as a Description.</p> <pre><code>var item = new Item(new Identifier(\"The items name\"), new Description(\"The items description.\"));\n</code></pre> <p>However, sometimes it may be desirable to have a conditional description that can change based on the state of the asset.</p> <p>Conditional descriptions can be specified with ConditionalDescription and contain a lambda which determines which one of two strings are returned when the asset is examined.</p> <pre><code>// the player, just for demo purposes\nvar player = new PlayableCharacter(\"Ben\", \"A man.\");\n\n// the description to use when the condition is true\nvar trueString = \"A gleaming sword, owned by Ben.\";\n\n// the string to use when the condition is false\nvar falseString = \"A gleaming sword, without an owner.\";\n\n// a lambda that determines which string is returned\nCondition condition = () =&gt; player.FindItem(\"Sword\", out _);\n\n// the conditional description itself\nvar conditionalDescrption = new ConditionalDescription(trueString, falseString, condition);\n\n// create the item with the conditional description\nvar sword = new Item(new Identifier(\"Sword\"), conditionalDescrption);\n</code></pre>"},{"location":"end-conditions/","title":"End Conditions","text":""},{"location":"end-conditions/#overview","title":"Overview","text":"<p>The EndCheck class allows the game to determine if it has come to an end. Each game has two end conditions * GameOverCondition when the game is over, but has not been won. * CompletionCondition when the game is over because it has been won.</p>"},{"location":"end-conditions/#use","title":"Use","text":"<p>When an EndCheck is invoked it returns an EndCheckResult. The EndCheckResult details the result of the check to see if the game has ended.</p> <pre><code>private static EndCheckResult IsGameOver(Game game)\n{\n    if (game.Player.IsAlive)\n        return EndCheckResult.NotEnded;\n\n    return new EndCheckResult(true, \"Game Over\", \"You died!\");\n}\n</code></pre> <p>This method can be used as an EndCheck:</p> <pre><code>EndCheck gameOverCheck = IsGameOver;\n</code></pre> <p>The GameOverCondition and CompletionCondition are passed in to the game as arguments when a game is created.</p>"},{"location":"exit/","title":"Exit","text":""},{"location":"exit/#overview","title":"Overview","text":"<p>An Exit is essentially a connector between to adjoining rooms.</p>"},{"location":"exit/#use","title":"Use","text":"<p>An Exit can be simply instantiated with a direction.</p> <pre><code>var exit = new Exit(Direction.North);\n</code></pre> <p>An Exit can be hidden from the player by setting its IsPlayerVisible property to false, this can be set in the constructor.</p> <pre><code>var exit = new Exit(Direction.North, false);\n</code></pre> <p>Or set explicitly.</p> <pre><code>exit.IsPlayerVisible = false;\n</code></pre> <p>Optionally, a description of the Exit can be specified.</p> <pre><code>var exit = new Exit(Direction.North, true, new Description(\"A door covered in ivy.\"));\n</code></pre> <p>This will be returned if the player examines the Exit.</p> <p>Like all Examinable objects, an Exit can be assigned custom commands.</p> <pre><code>exit.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Shove\", \"Shove the door.\"), true, (game, args) =&gt;\n    {\n        exit.Unlock();\n        return new Reaction(ReactionResult.OK, \"The door swung open.\");\n    })\n];\n</code></pre>"},{"location":"frame-builders/","title":"Overview","text":"<p>In BP.AdventureFramework output is handled using the FrameBuilders. A FrameBuilder is essentially a class that builds a Frame that can render a specific state in the game. This Frame can then be rendered on a TextWriter by calling its Render method. Think of the FrameBuilder as the instructions that build the output display and the Frame as the output itself.</p> <p>There are a few types of FrameBuilder, each responsible for rendering a specific game state. * SceneFrameBuilder is responsible for building frames that render the scenes in a game. * TitleFrameBuilder is responsible for building the title screen frame. * RegionMapFrameBuilder is responsible for building a frame that displays a map of a Region. * TransitionFrameBuilder is responsible for building frames that display transitions. * AboutFrameBuilder is responsible for building a frame to display the about information. * HelpFrameBuilder is responsible for building frames to display the help. * GameOverFrameBuilder is responsible for building a frame to display the game over screen. * CompletionFrameBuilder is responsible for building a frame to display the completion screen. * ConversationFrameBuilder is responsible for building a frame that can render a conversation.</p> <p>A game accepts a FrameBuilderCollection. A FrameBuilderCollection is a collection of all of the different FrameBuilders required to render a game. All FrameBuilders are extensible, so the output for all parts of the game can be fully customised.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#adding-the-nuget-package-to-your-project","title":"Adding the NuGet package to your project","text":"<p>You need to pull BP.AdventureFramework into your project. The easiest way to do this is to add the NuGet package. The latest package and installation instructions are available here.</p>"},{"location":"getting-started/#first-game","title":"First Game","text":"<p>Once the package has been installed it's time to jump in and start building your first game.</p>"},{"location":"getting-started/#setup","title":"Setup","text":"<p>To start with create a new Console application. Regardless of target framework, it should look something like this:</p> <pre><code>namespace BP.AdventureFramework.GettingStarted\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#adding-a-playablecharacter","title":"Adding a PlayableCharacter","text":"<p>Every game requires a character to play as, lets add that next:</p> <pre><code>private static PlayableCharacter CreatePlayer()\n{\n    return new PlayableCharacter(\"Dave\", \"A young boy on a quest to find the meaning of life.\");\n}\n</code></pre> <p>In this example whenever CreatePlayer is called a new PlayableCharacter will be created. The character is called \"Dave\" and has a description that describes him as \"A young boy on a quest to find the meaning of life.\".</p>"},{"location":"getting-started/#creating-the-game-world","title":"Creating the game world","text":"<p>The game world consists of a hierarchy of three tiers: Overworld, Region and Room. We will create a simple Region with two Rooms. We can do this directly in the Main function for simplicity. To start with lets make the Rooms:</p> <pre><code>private static void Main(string[] args)\n{\n    var cavern = new Room(\"Cavern\", \"A dark cavern set in to the base of the mountain.\", new Exit(Direction.North));\n\n    var tunnel = new Room(\"Tunnel\", \"A dark tunnel leading inside the mountain.\", new Exit(Direction.South));\n}\n</code></pre> <p>Although the Rooms haven't been added to a Region yet there are exits in place that will allow the player to move between them.</p> <p>Games are boring without Items to interact with, let's add an item to the tunnel:</p> <pre><code>var holyGrail = new Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true);\n\ntunnel.AddItem(holyGrail);\n</code></pre> <p>Looking good, but the Rooms need to be contained within a Region. RegionMaker simplifies this process, but sometimes creating a Region directly may be more appropriate if more control is needed. Here we will use RegionMaker:</p> <pre><code>var regionMaker = new RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\")\n{\n    [0, 0, 0] = cavern,\n    [0, 1, 0] = tunnel\n};\n</code></pre> <p>This needs more breaking down. The RegionMaker will create a region called \"Mountain\" with a description of \"An imposing volcano just East of town.\". The region will contain two rooms, the cavern and the tunnel. The cavern will be added at position x 0, y 0, z 0. The tunnel will be added at position x 0, y 1, z 0, north of the cavern.</p> <p>The game world is nearly complete, but the Region needs to exist within an Overworld for it to be finished. We will use OverworldMaker to achieve this:</p> <pre><code>var overworldMaker = new OverworldMaker(\"Daves World\", \"An ancient kingdom.\", regionMaker);\n</code></pre> <p>This will create an Overworld called \"Daves World\" which is described as \"An ancient kingdom\" and contains a single Region.</p> <p>All together the code looks like this:</p> <pre><code>var cavern = new Room(\"Cavern\", \"A dark cavern set in to the base of the mountain.\", new Exit(Direction.North));\n\nvar tunnel = new Room(\"Tunnel\", \"A dark tunnel leading inside the mountain.\", new Exit(Direction.South));\n\nvar holyGrail = new Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true);\n\ntunnel.AddItem(holyGrail);\n\nvar regionMaker = new RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\")\n{\n    [0, 0, 0] = cavern,\n    [0, 1, 0] = tunnel\n};\n\nvar overworldMaker = new OverworldMaker(\"Daves World\", \"An ancient kingdom.\", regionMaker);\n</code></pre>"},{"location":"getting-started/#checking-the-game-is-complete","title":"Checking the game is complete","text":"<p>For a game to come to an end it needs to either hit a game over state or a completion state.</p> <p>Firstly lets look at the logic that determines if the game is complete. An EndCheck is required, which returns an EndCheckResult that determines if the game is complete.</p> <p>In this example lets make a method that determines if the game is complete. The game is complete if the player has the holy grail:</p> <pre><code>private static EndCheckResult IsGameComplete(Game game)\n{\n    if (!game.Player.FindItem(\"Holy Grail\", out _))\n        return EndCheckResult.NotEnded;\n\n    return new EndCheckResult(true, \"Game Complete\", \"You have the Holy Grail!\");\n}\n</code></pre> <p>If the player has the holy grail then the EndCheckResult will return that the game has ended, and have a title that will read \"Game Complete\" and a description that reads \"You have the Holy Grail!\".</p> <p>A common game over state may be if the player dies:</p> <pre><code>private static EndCheckResult IsGameOver(Game game)\n{\n    if (game.Player.IsAlive)\n        return EndCheckResult.NotEnded;\n\n    return new EndCheckResult(true, \"Game Over\", \"You died!\");\n}\n</code></pre>"},{"location":"getting-started/#creating-the-game","title":"Creating the game","text":"<p>The game now has all the required assets and logic it just needs some boilerplate to tie everything together before it is ready to play.</p> <p>A GameCreationCallback is required to instantiate an instance of a Game. This is so that new instances of the Game can be created as required.</p> <pre><code>var gameCreator = Game.Create(\n    \"The Life Of Dave\",\n    \"Dave awakes to find himself in a cavern...\",\n    \"A very low budget adventure.\",\n    x =&gt; overworldMaker.Make(),\n    CreatePlayer,\n    IsGameComplete,\n    IsGameOver);\n</code></pre> <p>This requires some breaking down. The Game class has a Create method that can be used to create instances of Game. This takes the following arguments: * Name - the name of the game. * Introduction - an introduction to the game. * Description - a description of the game. * OverworldGenerator - a callback for generating instances of the overworld. * PlayerGenerator - a callback for generating instances of the player. * CompletionCondition - a callback for determining if the game is complete. * GameOverCondition - a callback for determining if the game is over.</p>"},{"location":"getting-started/#executing-the-game","title":"Executing the game","text":"<p>The game is executed simply by calling the static Execute method on Game and passing in the game creation callback.</p> <pre><code>Game.Execute(gameCreator);\n</code></pre>"},{"location":"getting-started/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The full example code should look like this:</p> <pre><code>using BP.AdventureFramework.Assets;\nusing BP.AdventureFramework.Assets.Characters;\nusing BP.AdventureFramework.Assets.Locations;\nusing BP.AdventureFramework.Logic;\nusing BP.AdventureFramework.Utilities;\n\nnamespace BP.AdventureFramework.GettingStarted\n{\n    internal class Program\n    {\n        private static EndCheckResult IsGameComplete(Game game)\n        {\n            if (!game.Player.FindItem(\"Holy Grail\", out _))\n                return EndCheckResult.NotEnded;\n\n            return new EndCheckResult(true, \"Game Complete\", \"You have the Holy Grail!\");\n        }\n\n        private static EndCheckResult IsGameOver(Game game)\n        {\n            if (game.Player.IsAlive)\n                return EndCheckResult.NotEnded;\n\n            return new EndCheckResult(true, \"Game Over\", \"You died!\");\n        }\n\n        private static PlayableCharacter CreatePlayer()\n        {\n            return new PlayableCharacter(\"Dave\", \"A young boy on a quest to find the meaning of life.\");\n        }\n\n        private static void Main(string[] args)\n        {\n            var cavern = new Room(\"Cavern\", \"A dark cavern set in to the base of the mountain.\", new Exit(Direction.North));\n\n            var tunnel = new Room(\"Tunnel\", \"A dark tunnel leading inside the mountain.\", new Exit(Direction.South));\n\n            var holyGrail = new Item(\"Holy Grail\", \"A dull golden cup, looks pretty old.\", true);\n\n            tunnel.AddItem(holyGrail);\n\n            var regionMaker = new RegionMaker(\"Mountain\", \"An imposing volcano just East of town.\")\n            {\n                [0, 0, 0] = cavern,\n                [0, 1, 0] = tunnel\n            };\n\n            var overworldMaker = new OverworldMaker(\"Daves World\", \"An ancient kingdom.\", regionMaker);\n\n            var gameCreator = Game.Create(\n                \"The Life Of Dave\",\n                \"Dave awakes to find himself in a cavern...\",\n                \"A very low budget adventure.\",\n                x =&gt; overworldMaker.Make(),\n                CreatePlayer,\n                IsGameComplete,\n                IsGameOver);\n\n            Game.Execute(gameCreator);\n        }\n    }\n}\n</code></pre> <p>Simply build and run the application and congratulations, you have a working BP.AdventureFramework game!</p>"},{"location":"items/","title":"Item","text":""},{"location":"items/#overview","title":"Overview","text":"<p>Items can be used to add interactivity with a game. Items can be something that a player can take with them, or they may be static in a Room.</p>"},{"location":"items/#use","title":"Use","text":"<p>An Item can be simply instantiated with a name and description.</p> <pre><code>var sword = new Item(\"Sword\", \"A heroes sword.\");\n</code></pre> <p>By default, an Item is not takeable and is tied to a Room. If it is takeable this can be specified in the constructor.</p> <pre><code>var sword = new Item(\"Sword\", \"A heroes sword.\", true);\n</code></pre> <p>An Item can morph in to another Item. This is useful in situations where the Item changes state. Morphing is invoked with the Morph method. The Item that Morph is invoked on takes on the properties of the Item being morphed into.</p> <pre><code>var brokenSword = new Item(\"Broken Sword\", \"A broken sword\");\nsword.Morph(brokenSword);\n</code></pre> <p>Like all Examinable objects, an Item can be assigned custom commands.</p> <pre><code>bomb.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Cut wire\", \"Cut the red wire.\"), true, (game, args) =&gt;\n    {\n        game.Player.Kill();\n        return new Reaction(ReactionResult.Fatal, \"Boom!\");\n    })\n];\n</code></pre>"},{"location":"items/#interaction","title":"Interaction","text":"<p>Interactions can be set up between different assets in the game. The InteractionResult contains the result of the interaction, and allows the game to react to the interaction.</p> <pre><code>var dartsBoard = new Item(\"Darts board\", \"A darts board.\");\n\nvar dart = new Item(\"Dart\", \"A dart\")\n{\n    Interaction = item =&gt;\n    {\n        if (item == dartsBoard)\n            return new InteractionResult(InteractionEffect.SelfContained, item, \"The dart stuck in the darts board.\");\n\n        return new InteractionResult(InteractionEffect.NoEffect, item);\n    }\n};\n</code></pre>"},{"location":"non-playable-character/","title":"NonPlayableCharacter","text":""},{"location":"non-playable-character/#overview","title":"Overview","text":"<p>A NonPlayableCharacter represents any character that the player may meet throughout the game.</p>"},{"location":"non-playable-character/#use","title":"Use","text":"<p>A NonPlayableCharacter can be simply instantiated with a name and description.</p> <pre><code>var goblin = new NonPlayableCharacter(\"Goblin\", \"A vile goblin.\");\n</code></pre> <p>A NonPlayableCharacter can give an item to another NonPlayableCharacter.</p> <pre><code>var daisy = new Item(\"Daisy\", \"A beautiful daisy that is sure to cheer up even the most miserable creature.\");\nnpc.Give(daisy, goblin);\n</code></pre> <p>NonPlayableCharacters can contain custom commands that allow the user to directly interact with the character or other assets.</p> <pre><code>goblin.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Smile\", \"Crack a smile.\"), true, (game, args) =&gt;\n    {\n        return new Reaction(ReactionResult.OK, \"Well that felt weird.\");\n    })\n];\n</code></pre>"},{"location":"non-playable-character/#conversations","title":"Conversations","text":"<p>A NonPlayableCharacter can hold a conversation with the player.  * A Conversation contains Paragraphs.  * A Paragraph can contain one or more Responses. * A Response can contain a delta to shift the conversation by, which will cause the conversation to jump paragraphs by the specified value. * A Response can also contain a callback to perform some action when the player selects that option.</p> <pre><code>goblin.Conversation = new Conversation(\n    new Paragraph(\"This is a the first line.\"),\n    new Paragraph(\"This is a question.\")\n    {\n        Responses =\n        [\n            new Response(\"This is the first response.\" 1),\n            new Response(\"This is the second response.\", 2),\n            new Response(\"This is the third response.\", 2)\n        ]\n    },\n    new Paragraph(\"You picked first response, return to start of conversation.\", -2),\n    new Paragraph(\"You picked second response, return to start of conversation., -2),\n    new Paragraph(\"You picked third response, you are dead., game =&gt; game.Player.Kill())\n);\n</code></pre>"},{"location":"overworld/","title":"Overworld","text":""},{"location":"overworld/#overview","title":"Overview","text":"<p>An Overworld is the top level location in a game. A game can only contain a single Overworld. An Overworld can contain multiple Regions.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre>"},{"location":"overworld/#use","title":"Use","text":"<p>An Overworld can be simply instantiated with a name and description.</p> <pre><code>var overworld = new Overworld(\"Name\", \"Description.\");\n</code></pre> <p>Regions can be added to the Overworld with the AddRegion method.</p> <pre><code>overworld.AddRegion(region);\n</code></pre> <p>Regions can be removed from an Overworld with the RemoveRegion method.</p> <pre><code>overworld.RemoveRegion(region);\n</code></pre> <p>The Overworld can be traversed with the Move method.</p> <pre><code>overworld.Move(region);\n</code></pre>"},{"location":"overworld/#overworldmaker","title":"OverworldMaker","text":"<p>The OverworldMaker simplifies the creation of the Overworld, when used in conjunction with RegionMakers.</p> <pre><code>var overworldMaker = new OverworldMaker(\"Name\", \"Description.\", regionMakers);\n</code></pre> <p>However, the main benefit of using an OverworldMaker is that it allows multiple instances of an Overworld to be created from a single definition of an Overworld.</p> <pre><code>var overworld = overworldMaker.Make();;\n</code></pre>"},{"location":"playable-character/","title":"PlayableCharacter","text":""},{"location":"playable-character/#overview","title":"Overview","text":"<p>A PlayableCharacter represents the character that the player plays as throughout the game. Each game has only a single PlayableCharacter.</p>"},{"location":"playable-character/#use","title":"Use","text":"<p>A PlayableCharacter can be simply instantiated with a name and description.</p> <pre><code>var player = new PlayableCharacter(\"Ben\", \"A 39 year old man.\");\n</code></pre> <p>A PlayableCharacter can be also be instantiated with a list of Items.</p> <pre><code>var player = new PlayableCharacter(\"Ben\", \"A 39 year old man.\",\n[\n    new Item(\"Guitar\", \"A PRS Custom 22, in whale blue, of course.\"),\n    new Item(\"Wallet\", \"An empty wallet, of course.\")\n]);\n</code></pre> <p>A PlayableCharacter can be given items with the AcquireItem method.</p> <pre><code>player.AcquireItem(new Item(\"Mallet\", \"A large mallet.\"));\n</code></pre> <p>A PlayableCharacter can lose an item with the DequireItem method.</p> <pre><code>player.DequireItem(mallet);\n</code></pre> <p>A PlayableCharacter can use an item on another asset:</p> <pre><code>var trapDoor = new Exit(Direction.Down);\nvar mallet = new Item(\"Mallet\", \"A large mallet.\");\nplayer.UseItem(mallet, trapDoor);\n</code></pre> <p>A PlayableCharacter cn give an item to a non-playable character.</p> <pre><code>var goblin = new NonPlayableCharacter(\"Goblin\", \"A vile goblin.\");\nvar daisy = new Item(\"Daisy\", \"A beautiful daisy that is sure to cheer up even the most miserable creature.\");\nplayer.Give(daisy, goblin);\n</code></pre> <p>PlayableCharacters can contain custom commands that allow the user to directly interact with the character or other assets.</p> <pre><code>player.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Punch wall\", \"Punch the wall.\"), true, (game, args) =&gt;\n    {\n        return new Reaction(ReactionResult.OK, \"You punched the wall.\");\n    })\n];\n</code></pre>"},{"location":"region/","title":"Region","text":""},{"location":"region/#overview","title":"Overview","text":"<p>A Region is the intermediate level location in a game. An Overworld can contain multiple Regions. A Region can contain multiple Rooms.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre> <p>A Region represents a 3D space.  * The x location always refers to the horizontal axis, with lower values being west and higher values being east. * The y location always refers to the vertical axis, with lower values being south and higher values being north. * The z location always refers to the depth axis, with lower values being down and higher values being up.</p>"},{"location":"region/#use","title":"Use","text":"<p>A Region can be simply instantiated with a name and description.</p> <pre><code>var region = new Region(\"Name\", \"Description.\");\n</code></pre> <p>Rooms can be added to the Region with the AddRoom method. The x, y and z location within the Region must be specified.</p> <pre><code>region.AddRoom(room, 0, 0, 0);\n</code></pre> <p>Rooms can be removed from a Region with the RemoveRoom method.</p> <pre><code>region.RemoveRoom(room);\n</code></pre> <p>The Region can be traversed with the Move method.</p> <pre><code>region.Move(Direction.North);\n</code></pre> <p>The Region can be traversed with the Move method.</p> <pre><code>region.Move(Direction.North);\n</code></pre> <p>The start position, that is the position that the Player will start in when entering a Region, can be specified with SetStartPosition.</p> <pre><code>region.SetStartPosition(0, 0, 0);\n</code></pre> <p>The UnlockDoorPair method can be used to unlock an Exit in the current Room, which will also unlock the corresponding Exit in the adjoining Room.</p> <pre><code>region.UnlockDoorPair(Direction.East);\n</code></pre> <p>Like all Examinable objects, Regions can be assigned custom commands.</p> <pre><code>region.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Warp\", \"Warp to the start.\"), true, (game, args) =&gt;\n    {\n        region.JumpToRoom(0, 0, 0);\n        return new Reaction(ReactionResult.OK, \"You warped to the start.\");\n    })\n];\n</code></pre>"},{"location":"region/#regionmaker","title":"RegionMaker","text":"<p>The RegionMaker simplifies the creation of a Region. Rooms are added to the Region with a specified x, y and z position within the Region.</p> <pre><code>var regionMaker = new RegionMaker(\"Region\", \"Description.\")\n{\n    [0, 0, 0] = new Room(\"Room 1\", \"Description of room 1.\"),\n    [1, 0, 0] = new Room(\"Room 2\", \"Description of room 2.\"),\n};\n</code></pre> <p>The main benefit of using a RegionMaker is that it allows multiple instances of a Region to be created from a single definition of a Region.</p> <pre><code>var region = regionMaker.Make();\n</code></pre>"},{"location":"room/","title":"Room","text":""},{"location":"room/#overview","title":"Overview","text":"<p>A Room is the lowest level location in a game. A Region can contain multiple Rooms.</p> <pre><code>Overworld\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n\u251c\u2500\u2500 Region\n\u2502   \u251c\u2500\u2500 Room\n\u2502   \u251c\u2500\u2500 Room\n</code></pre> <p>A Room can contain up to six Exits, one for each of the directions north, east, south, west, up and down.</p>"},{"location":"room/#use","title":"Use","text":"<p>A Region can be simply instantiated with a name and description.</p> <pre><code>var room = new Room(\"Name\", \"Description.\");\n</code></pre> <p>Exits can be added to the Room with the AddExit method.</p> <pre><code>room.AddExit(new Exit(Direction.East));\n</code></pre> <p>Exits can be removed from a Room with the RemoveExit method.</p> <pre><code>region.RemoveExit(exit);\n</code></pre> <p>Items can be added to the Room with the AddItem method.</p> <pre><code>room.AddItem(new Item(\"Name\", \"Description.\"));\n</code></pre> <p>Items can be removed from a Room with the RemoveItem method.</p> <pre><code>region.RemoveItem(item);\n</code></pre> <p>Characters can be added to the Room with the AddCharacter method.</p> <pre><code>room.AddCharacter(new Character(\"Name\", \"Description.\"));\n</code></pre> <p>Characters can be removed from a Room with the RemoveCharacter method.</p> <pre><code>region.RemoveCharacter(character);\n</code></pre> <p>Rooms can contain custom commands that allow the user to directly interact with the Room.</p> <pre><code>room.Commands =\n[\n    new CustomCommand(new CommandHelp(\"Pull lever\", \"Pull the lever.\"), true, (game, args) =&gt;\n    {\n        room.FindExit(Direction.East, true, out var exit);\n        exit.Unlock();\n        return new Reaction(ReactionResult.OK, \"The exit was unlocked.\");\n    })\n];\n</code></pre>"}]}